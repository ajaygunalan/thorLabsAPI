<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SpectralRadar SDK: Acquisition</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="doxyfile_header.bmp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SpectralRadar SDK
   &#160;<span id="projectnumber">5.2</span>
   </div>
   <div id="projectbrief">C Reference for OCT Development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___acquisition.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Acquisition</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions for acquisition.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gab9cfa077fb6f42b203da94f3bb41d3a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___acquisition.html#gab9cfa077fb6f42b203da94f3bb41d3a9">AcquisitionType</a> { <br />
&#160;&#160;<a class="el" href="group___acquisition.html#gab9cfa077fb6f42b203da94f3bb41d3a9a05389fd6c7d043c399a521fba8d2b93c">Acquisition_AsyncContinuous</a>, 
<br />
&#160;&#160;<a class="el" href="group___acquisition.html#gab9cfa077fb6f42b203da94f3bb41d3a9ab3296b03a13050c377aac8b3fb65aa5c">Acquisition_AsyncFinite</a>, 
<br />
&#160;&#160;<a class="el" href="group___acquisition.html#gab9cfa077fb6f42b203da94f3bb41d3a9a53324165eec42ea1fc5f3b0bd5998f10">Acquisition_Sync</a>
<br />
 }<tr class="memdesc:gab9cfa077fb6f42b203da94f3bb41d3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the kind of acquisition process. The type of acquisition process affects e.g. whether consecutive B-scans are acquired or if it is possible to lose some data.  <a href="group___acquisition.html#gab9cfa077fb6f42b203da94f3bb41d3a9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gab9cfa077fb6f42b203da94f3bb41d3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga79b9d0de68c1603132775f79ce72cf6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_spectral_radar_8h.html#a7a11a733934fde30318f20c31ea1f47f">SPECTRALRADAR_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___acquisition.html#ga79b9d0de68c1603132775f79ce72cf6d">projectMemoryRequirement</a> (<a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a> Handle, <a class="el" href="group___scan_pattern.html#ga5895a3257f7a22480e2aa27f261a6e26">ScanPatternHandle</a> Pattern, <a class="el" href="group___acquisition.html#gab9cfa077fb6f42b203da94f3bb41d3a9">AcquisitionType</a> type)</td></tr>
<tr class="memdesc:ga79b9d0de68c1603132775f79ce72cf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the required memory, e.g. for a raw data object, in bytes to acquire the scan pattern once.  <a href="#ga79b9d0de68c1603132775f79ce72cf6d">More...</a><br /></td></tr>
<tr class="separator:ga79b9d0de68c1603132775f79ce72cf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga781d95b2577869c6e3277124518c534e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_spectral_radar_8h.html#a7a11a733934fde30318f20c31ea1f47f">SPECTRALRADAR_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___acquisition.html#ga781d95b2577869c6e3277124518c534e">startMeasurement</a> (<a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a> Dev, <a class="el" href="group___scan_pattern.html#ga5895a3257f7a22480e2aa27f261a6e26">ScanPatternHandle</a> Pattern, <a class="el" href="group___acquisition.html#gab9cfa077fb6f42b203da94f3bb41d3a9">AcquisitionType</a> Type)</td></tr>
<tr class="memdesc:ga781d95b2577869c6e3277124518c534e"><td class="mdescLeft">&#160;</td><td class="mdescRight">starts a continuous measurement BScans.  <a href="#ga781d95b2577869c6e3277124518c534e">More...</a><br /></td></tr>
<tr class="separator:ga781d95b2577869c6e3277124518c534e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab76ba00c4c10102accc16e9341c1fd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_spectral_radar_8h.html#a7a11a733934fde30318f20c31ea1f47f">SPECTRALRADAR_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___acquisition.html#gaab76ba00c4c10102accc16e9341c1fd3">getRawData</a> (<a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a> Dev, <a class="el" href="group___data.html#ga485ecd235dcc8605e6803a8fa5bc4426">RawDataHandle</a> RawData)</td></tr>
<tr class="memdesc:gaab76ba00c4c10102accc16e9341c1fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires data and stores the data unprocessed.  <a href="#gaab76ba00c4c10102accc16e9341c1fd3">More...</a><br /></td></tr>
<tr class="separator:gaab76ba00c4c10102accc16e9341c1fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga236ca7c62ed1572d69352cdb1ae5aa2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_spectral_radar_8h.html#a7a11a733934fde30318f20c31ea1f47f">SPECTRALRADAR_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___acquisition.html#ga236ca7c62ed1572d69352cdb1ae5aa2f">getRawDataEx</a> (<a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a> Dev, <a class="el" href="group___data.html#ga485ecd235dcc8605e6803a8fa5bc4426">RawDataHandle</a> RawData, int CameraIdx)</td></tr>
<tr class="memdesc:ga236ca7c62ed1572d69352cdb1ae5aa2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires data with the specific camera given with camera index and stores the data unprocessed.  <a href="#ga236ca7c62ed1572d69352cdb1ae5aa2f">More...</a><br /></td></tr>
<tr class="separator:ga236ca7c62ed1572d69352cdb1ae5aa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b1a7ed17091fa0f3aeb56128f2b3d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_spectral_radar_8h.html#a7a11a733934fde30318f20c31ea1f47f">SPECTRALRADAR_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___acquisition.html#ga4b1a7ed17091fa0f3aeb56128f2b3d91">stopMeasurement</a> (<a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a> Dev)</td></tr>
<tr class="memdesc:ga4b1a7ed17091fa0f3aeb56128f2b3d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">stops the current measurement.  <a href="#ga4b1a7ed17091fa0f3aeb56128f2b3d91">More...</a><br /></td></tr>
<tr class="separator:ga4b1a7ed17091fa0f3aeb56128f2b3d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba075171a42931d5fa927089e3e1023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_spectral_radar_8h.html#a7a11a733934fde30318f20c31ea1f47f">SPECTRALRADAR_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___acquisition.html#gaeba075171a42931d5fa927089e3e1023">measureSpectra</a> (<a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a> Dev, int NumberOfSpectra, <a class="el" href="group___data.html#ga485ecd235dcc8605e6803a8fa5bc4426">RawDataHandle</a> Raw)</td></tr>
<tr class="memdesc:gaeba075171a42931d5fa927089e3e1023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the desired number of spectra (raw data without processing) without moving galvo scanners.  <a href="#gaeba075171a42931d5fa927089e3e1023">More...</a><br /></td></tr>
<tr class="separator:gaeba075171a42931d5fa927089e3e1023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e3b256e5ed6cb45b04799e0b800ac5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_spectral_radar_8h.html#a7a11a733934fde30318f20c31ea1f47f">SPECTRALRADAR_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___acquisition.html#ga3e3b256e5ed6cb45b04799e0b800ac5d">measureSpectraEx</a> (<a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a> Dev, int NumberOfSpectra, <a class="el" href="group___data.html#ga485ecd235dcc8605e6803a8fa5bc4426">RawDataHandle</a> Raw, int CameraIndex)</td></tr>
<tr class="memdesc:ga3e3b256e5ed6cb45b04799e0b800ac5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the desired number of spectra (raw data without processing) without moving galvo scanners, for the desired camera.  <a href="#ga3e3b256e5ed6cb45b04799e0b800ac5d">More...</a><br /></td></tr>
<tr class="separator:ga3e3b256e5ed6cb45b04799e0b800ac5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions for acquisition. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gab9cfa077fb6f42b203da94f3bb41d3a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___acquisition.html#gab9cfa077fb6f42b203da94f3bb41d3a9">AcquisitionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the kind of acquisition process. The type of acquisition process affects e.g. whether consecutive B-scans are acquired or if it is possible to lose some data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gab9cfa077fb6f42b203da94f3bb41d3a9a05389fd6c7d043c399a521fba8d2b93c"></a>Acquisition_AsyncContinuous&#160;</td><td class="fielddoc">
<p>Specifies an asynchronous infinite/continuous measurement. With this acquisition type an infinite loop to acquire the specified scan pattern will be started and stopped with the call of <a class="el" href="group___acquisition.html#ga4b1a7ed17091fa0f3aeb56128f2b3d91" title="stops the current measurement. ">stopMeasurement</a>. Several buffers will be created internally to hold the data of the specified scan pattern several times. With this acquisiton mode it is possible to lose data if the acquisition is faster than the copying from the framegrabber with <a class="el" href="group___acquisition.html#gaab76ba00c4c10102accc16e9341c1fd3" title="Acquires data and stores the data unprocessed. ">getRawData</a>. If you lose data you will always lose a whole frame, e.g. a whole B-scan. The acquisiton thread runs independently from the thread for grabbing the data to acquire the data as fast as possible. To get the information whether the data of a whole scan pattern got lost please use <a class="el" href="group___data.html#gaad9e66f0b7d20f8e215ed63e0ab8914f" title="Notice that raw data refers to the spectra as acquired, without processing of any kind...">getRawDataPropertyInt</a> with <a class="el" href="_spectral_radar_8h.html#ga107bc69af20eee4547a63d089c23e60ca6f75c729bff7ea4297868d27d952c77f" title="The number of lost frames during data acqusition. ">RawData_LostFrames</a> when grabbing the data. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gab9cfa077fb6f42b203da94f3bb41d3a9ab3296b03a13050c377aac8b3fb65aa5c"></a>Acquisition_AsyncFinite&#160;</td><td class="fielddoc">
<p>Specifies an asynchronous finite measurement. With this acquisitions type enough memory is created internally to hold the data for the whole scan pattern once. Therefore it is guaranteed to grab all the data and not losing frames. Please note that it is possible to acquire the scan pattern once only with this acquisition mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gab9cfa077fb6f42b203da94f3bb41d3a9a53324165eec42ea1fc5f3b0bd5998f10"></a>Acquisition_Sync&#160;</td><td class="fielddoc">
<p>Specfies a synchronous measurement. With this acquisition mode the acquisition of the specified scan pattern will be started with the call of <a class="el" href="group___acquisition.html#gaab76ba00c4c10102accc16e9341c1fd3" title="Acquires data and stores the data unprocessed. ">getRawData</a>. You can interpret this acquisition type as a software trigger to start the measurement. To start the data acquisition externally please see the chapter in the software manual about external triggering. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaab76ba00c4c10102accc16e9341c1fd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getRawData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a>&#160;</td>
          <td class="paramname"><em>Dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data.html#ga485ecd235dcc8605e6803a8fa5bc4426">RawDataHandle</a>&#160;</td>
          <td class="paramname"><em>RawData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires data and stores the data unprocessed. </p>
<p>In case of a synchronic measurement, this function will trigger the data acquisition. Otherwise it will return the latest acquired data buffer. In any case, this function will block until a data buffer is available (asynchronic measurements may satistfy this requirement immediately if a previously acquired buffer has not already been consumed).<br />
This function is equivalent to</p><div class="fragment"><div class="line"><a class="code" href="group___acquisition.html#ga236ca7c62ed1572d69352cdb1ae5aa2f">getRawDataEx</a>(Dev, RawData, 0);</div></div><!-- fragment --><p>. In other words, in systems with more than just one camera, this function retrieves the raw data of the first camera.<br />
Notice that raw data refers to the spectra as acquired, without processing of any kind.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Dev</td><td>A valid (non null) OCT device handle (<a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61" title="The OCTDeviceHandle type is used as Handle for using the SpectralRadar. ">OCTDeviceHandle</a>), previously generated with the function <a class="el" href="group___hardware.html#gaaf321357880c083c89a8879a2d9c26a2" title="Initializes the installed device. ">initDevice</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RawData</td><td>A valid (non null) raw data handle (<a class="el" href="group___data.html#ga485ecd235dcc8605e6803a8fa5bc4426" title="Handle to an object holding the unprocessed raw data. ">RawDataHandle</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga236ca7c62ed1572d69352cdb1ae5aa2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getRawDataEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a>&#160;</td>
          <td class="paramname"><em>Dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data.html#ga485ecd235dcc8605e6803a8fa5bc4426">RawDataHandle</a>&#160;</td>
          <td class="paramname"><em>RawData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CameraIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires data with the specific camera given with camera index and stores the data unprocessed. </p>
<p>In case of a synchronic measurement, this function will trigger the data acquisition. Otherwise it will return the latest acquired data buffer. In any case, this function will block until a data buffer is available (asynchronic measurements may satistfy this requirement immediately if a previously acquired buffer has not already been consumed).<br />
In systems with more than one camera, the hardware connections ensure that all cameras measure simultaneoulsy. That is, they have a common trigger. The master camera (index 0) will actually trigger the measurement of all slaves. for this reason, this function should be invoked first for the master (index 0) and only afterwards for the slaves (index greater than 0). If a slave triggers first, it will wait for the master (that is, this function call will block the current execution thread). If the master triggers first, the buffer for the slave will be ready for pick up by the time the slave retrieves (without blocking).<br />
Notice that raw data refers to the spectra as acquired, without processing of any kind.</p>
<dl class="section warning"><dt>Warning</dt><dd>{Unless the program divides the acquistion in different threads, this function should be invoked first for the master camera (<code>CameraIdx</code> = 0) and only then for the slaves. Otherwise it will block for ever.} </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Dev</td><td>A valid (non null) OCT device handle (<a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61" title="The OCTDeviceHandle type is used as Handle for using the SpectralRadar. ">OCTDeviceHandle</a>), previously generated with the function <a class="el" href="group___hardware.html#gaaf321357880c083c89a8879a2d9c26a2" title="Initializes the installed device. ">initDevice</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RawData</td><td>A valid (non null) raw data handle (<a class="el" href="group___data.html#ga485ecd235dcc8605e6803a8fa5bc4426" title="Handle to an object holding the unprocessed raw data. ">RawDataHandle</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CameraIdx</td><td>The camera index (0-based, i.e. zero for the first = master, one for the second, and so on). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeba075171a42931d5fa927089e3e1023"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void measureSpectra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a>&#160;</td>
          <td class="paramname"><em>Dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumberOfSpectra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data.html#ga485ecd235dcc8605e6803a8fa5bc4426">RawDataHandle</a>&#160;</td>
          <td class="paramname"><em>Raw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the desired number of spectra (raw data without processing) without moving galvo scanners. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Dev</td><td>A valid (non null) OCT device handle (<a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61" title="The OCTDeviceHandle type is used as Handle for using the SpectralRadar. ">OCTDeviceHandle</a>), previously generated with the function <a class="el" href="group___hardware.html#gaaf321357880c083c89a8879a2d9c26a2" title="Initializes the installed device. ">initDevice</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NumberOfSpectra</td><td>The desired number of spectra. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Raw</td><td>A valid (non null) handle of raw data (<a class="el" href="group___data.html#ga485ecd235dcc8605e6803a8fa5bc4426" title="Handle to an object holding the unprocessed raw data. ">RawDataHandle</a>), where the acquired spectra will be stored. The meta data (dimensions, sizes, bytes per pixel, etc.) will be adjusted automatically.</td></tr>
  </table>
  </dd>
</dl>
<p>This procedure assumes that there is no any ongoing measurement process (started with the function <a class="el" href="group___acquisition.html#ga781d95b2577869c6e3277124518c534e" title="starts a continuous measurement BScans. ">startMeasurement</a>). The indicated number of measurements will be carried out. The user should not stop the measurement (this function will block till the whole data is ready).<br />
If the hardware contains more than one camera, all cameras will be triggered, because the hardware has been setup to do so. This function will return raw data only for the first camera (the master). The raw data for the slaves, acquired simultaneously, will be available for retrieval any time afterwards (the function <a class="el" href="group___acquisition.html#ga3e3b256e5ed6cb45b04799e0b800ac5d" title="Acquires the desired number of spectra (raw data without processing) without moving galvo scanners...">measureSpectraEx</a> should be used).<br />
This function blocks till the desired number of spectra get written in the indicated buffer (<code>Raw</code>).<br />
Notice that raw data refers to the spectra as acquired, without processing of any kind. </p>

</div>
</div>
<a class="anchor" id="ga3e3b256e5ed6cb45b04799e0b800ac5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void measureSpectraEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a>&#160;</td>
          <td class="paramname"><em>Dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NumberOfSpectra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___data.html#ga485ecd235dcc8605e6803a8fa5bc4426">RawDataHandle</a>&#160;</td>
          <td class="paramname"><em>Raw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CameraIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires the desired number of spectra (raw data without processing) without moving galvo scanners, for the desired camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Dev</td><td>A valid (non null) OCT device handle (<a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61" title="The OCTDeviceHandle type is used as Handle for using the SpectralRadar. ">OCTDeviceHandle</a>), previously generated with the function <a class="el" href="group___hardware.html#gaaf321357880c083c89a8879a2d9c26a2" title="Initializes the installed device. ">initDevice</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NumberOfSpectra</td><td>The desired number of spectra. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Raw</td><td>A valid (non null) handle of raw data (<a class="el" href="group___data.html#ga485ecd235dcc8605e6803a8fa5bc4426" title="Handle to an object holding the unprocessed raw data. ">RawDataHandle</a>), where the acquired spectra will be stored. The meta data (dimensions, sizes, bytes per pixel, etc.) will be adjusted automatically. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CameraIndex</td><td>The camera index (0-based, i.e. zero for the first = master, one for the second, and so on). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>{Unless the program divides the acquistion in different threads, this function should be invoked first for the master camera (<code>CameraIdx</code> = 0) and only then for the slaves. Otherwise it will block for ever.}</dd></dl>
<p>This procedure assumes that there is no any ongoing measurement process (started with the function <a class="el" href="group___acquisition.html#ga781d95b2577869c6e3277124518c534e" title="starts a continuous measurement BScans. ">startMeasurement</a>). The indicated number of measurements will be carried out. The user should not stop the measurement (this function will block till the whole data is ready).<br />
If the hardware contains more than one camera, all cameras will be triggered together with the first one (the master), because the hardware has been setup to do so. If <code>CameraIdx</code> is different from zero, i.e. a slave is meant, this function will retrieve the spectra measured together with the master. If those data happen to be already consumed, this function will block until the master triggers. Notice that in a single thread programming model, the program would stop execution for ever. For this reason, it is strongly adviced to invoke this function first for the master (<code>CameraIdx</code> = 0) and only then for the slaves.<br />
This function will retrieve raw data only for the selected camera. The user must invoke this function for each camera separately, but in judicious order, as explained before.<br />
This function blocks till the desired number of spectra get written in the indicated buffer (<code>Raw</code>).<br />
Notice that raw data refers to the spectra as acquired, without processing of any kind. </p>

</div>
</div>
<a class="anchor" id="ga79b9d0de68c1603132775f79ce72cf6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t projectMemoryRequirement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a>&#160;</td>
          <td class="paramname"><em>Handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___scan_pattern.html#ga5895a3257f7a22480e2aa27f261a6e26">ScanPatternHandle</a>&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___acquisition.html#gab9cfa077fb6f42b203da94f3bb41d3a9">AcquisitionType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the required memory, e.g. for a raw data object, in bytes to acquire the scan pattern once. </p>

</div>
</div>
<a class="anchor" id="ga781d95b2577869c6e3277124518c534e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void startMeasurement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a>&#160;</td>
          <td class="paramname"><em>Dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___scan_pattern.html#ga5895a3257f7a22480e2aa27f261a6e26">ScanPatternHandle</a>&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___acquisition.html#gab9cfa077fb6f42b203da94f3bb41d3a9">AcquisitionType</a>&#160;</td>
          <td class="paramname"><em>Type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>starts a continuous measurement BScans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Dev</td><td>A valid (non null) OCT device handle (<a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61" title="The OCTDeviceHandle type is used as Handle for using the SpectralRadar. ">OCTDeviceHandle</a>), previously generated with the function <a class="el" href="group___hardware.html#gaaf321357880c083c89a8879a2d9c26a2" title="Initializes the installed device. ">initDevice</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pattern</td><td>A valid (non null) scan pattern handle (<a class="el" href="group___scan_pattern.html#ga5895a3257f7a22480e2aa27f261a6e26" title="Handle for creating, manipulating, and discarding a scan pattern. ">ScanPatternHandle</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Type</td><td>This parameter (<a class="el" href="group___acquisition.html#gab9cfa077fb6f42b203da94f3bb41d3a9" title="Determines the kind of acquisition process. The type of acquisition process affects e...">AcquisitionType</a>) decides whether the acquisition proceeds asynchronic (continuous or finite) or synchronic.</td></tr>
  </table>
  </dd>
</dl>
<p>Scanning proceeds according to the specified scan pattern handle. In order to retrieve the acquired data, refer to the <a class="el" href="group___acquisition.html#gaab76ba00c4c10102accc16e9341c1fd3" title="Acquires data and stores the data unprocessed. ">getRawData()</a> function. To stop the measuring process, invoke <a class="el" href="group___acquisition.html#ga4b1a7ed17091fa0f3aeb56128f2b3d91" title="stops the current measurement. ">stopMeasurement()</a>.<br />
Synchronic measurements get triggered when the user invokes function that retrieves the data. Asynchronic measurements proceed in background, and the retrieving function returns the last available buffer that has been filled with fresh data. Asynchronic measurements can acquire a pre-specified number of buffers (finite) or continue indefinetely (continuous). If it is not possible to retrieve acquired data for a while, intermediate buffers might be skipped. </p>

</div>
</div>
<a class="anchor" id="ga4b1a7ed17091fa0f3aeb56128f2b3d91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stopMeasurement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61">OCTDeviceHandle</a>&#160;</td>
          <td class="paramname"><em>Dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stops the current measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Dev</td><td>A valid (non null) OCT device handle (<a class="el" href="group___hardware.html#ga4e904e17ea3a34cbedf75c1f4baa3b61" title="The OCTDeviceHandle type is used as Handle for using the SpectralRadar. ">OCTDeviceHandle</a>), previously generated with the function <a class="el" href="group___hardware.html#gaaf321357880c083c89a8879a2d9c26a2" title="Initializes the installed device. ">initDevice</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jun 28 2019 15:02:58 for SpectralRadar SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
